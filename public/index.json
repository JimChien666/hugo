[{"categories":["密碼學"],"contents":"定義:\na cipher defined over (K, M, C) is a pair of \u0026quot;efficient\u0026quot; algs (E, D) where E: K * M -\u0026gt; C, D: K * C -\u0026gt; M , s.t. ∀ m ∈ M, k ∈ K: D(k, E(k, m)) = m 在 (K, M, C) 密鑰空間上定義的密碼是一對\u0026quot;高效率\u0026quot;演算法 (E, D)，其中 E: K * M -\u0026gt; C, D: K*C -\u0026gt; M ,使其對於 M 中的所有 m，K 中的所有 k：D(k, E(k, m)) = m\n E 通常是個隨機演算法 D 通常是個確定性演算法  一次性加密(The One Time Pad) 明文 M 跟 密文 C 都是長度為 n 個 bit\nM = C = {0, 1}^n\nK = {0, 1}^n\nKey 是一個隨機且長度同樣為 n 個 bit\nC := E(k, m) = k ⊕ m\nm: 0 1 1 0 1 1 1 k: 1 0 1 1 0 0 1 ⊕ c: 1 1 0 1 1 1 0\nD(k, E(k, m)) = D(k, k ⊕ m) = k ⊕ (k ⊕ m) = k ⊕ k ⊕ m = m\n問題：給你一個 訊息 m 和 OTP 加密後的密文 c，可以算出 OTP 的密鑰 k嗎？\n答案：可以，密鑰 k 為 m ⊕ c\nOTP 不實用 當訊息 m 長度太長的時候，密鑰 k 也會很長，所以當 Ann 要和 Bob 對談時，Ann發送消息給 Bob，他傳送一條訊息，就要生成一條跟訊息一樣長的密鑰 k，但雖然不實用， OTP 卻很安全，怎麼樣才能說得上安全呢，我們得先定義\u0026quot;安全性\u0026quot;。\n密碼算法的安全性(Information Theoretic Security) (shannon 1949) 基礎想法: 密文不應該透露任何有關原文的消息。\n定義: A cipher (E, D) over (K, M, C) has perfect secrecy if\n∀ m0, m1 ∈ M (len(m0) = len(m1)) and ∀ c ∈ C Pr[E(k, m0) = c] = Pr[E(k, m1) = c] where k is uniform in K (k \u0026lt;-r K) 這個意思是當我拿到一串密文 c 時，我不能確定他的原文是 m0 還是 m1，因為他們的機率相等，所以攻擊者無法用密文進行攻擊。\nLemma: OTP has perfect secrecy\n證明:\n 前情提要：若一組明密文 m, c 的密鑰總數為常數，則 這個加密為 perfect secrecy  ∀ m, c: Pr[E(k, m) = c] = (#keys k ∈ K s.t. E(k, m) = c)/|K| so: ∀ m, c: #{k ∈ K: E(k, m) = c} = const. =\u0026gt; cipher has perfect secrecy 證明 OTP 為 perfect secrecy  For OTP: if E(k, m) = c =\u0026gt; k ⊕ m = c =\u0026gt; k = m ⊕ c =\u0026gt;#{k ∈ K: E(k, m) = c} = 1 ∀ m, c =\u0026gt; OTP has perfect secrecy 結論: 之前學到的替換加密法，因為英文字母的出現頻率，很容易透露出密文與原文之間的關係，但在 OTP 中，你無法找到密文與原文之間的關係。因為當你獲得密文 c 時，他的原文 m0, m1 機率相等，所以具有安全性。但是，還是有其他方法可能攻破這個 OTP，再他的密鑰太長，不方便使用。那麼是否有比較短的密鑰 k 也具備安全性呢。這邊有個結論。\nThm: perfect secrecy =\u0026gt; |K| \u0026gt;= |M| 這邊的意思是若要有 perfect secrecy，密鑰的長度必須大於原文的長度，也就是說，密鑰長度至少要等於原文長度，才有 perfect secrecy 特性。\n","permalink":"https://jimchien666.github.io/blog/crypto1/","tags":["密碼學"],"title":"對稱性加密(Symmetric Ciphers)"},{"categories":["Http"],"contents":"資源 (Resource) 當我們想要查看某篇文章，例如我的筆記中 Spring 中控制反轉及依賴注入 這篇文章時，我們會在瀏覽器中輸入網址 http://jimchien666.github.io/blog/post1，當瀏覽器回傳這個頁面時，我們就可以觀看這篇文章，這個回傳結果 (文章)，就是資源 (Resource)。\nURL 從前面知道我們輸入網址 http://jimchien666.github.io/blog/post1 可以得到資源，我們稱這個網址為 URL (uniform resource locator)，他定位了網路上的某個特定資源，也就是這篇文章，而資源不僅包含文章，圖像、影片、文件等等都是。不同的路徑，不同的 URL 就搭配不同的資源。\n而對於 URL，我們可以把他分成三個部分：\n  http，也就是 :// 之前的部分就是我們所說的URL scheme。說明他用什麼方式取得資源，這邊是用 http 方式取得資源。\n  jimchien666.github.io 就是主機(server)，我們可以從 DNS 系統查找到該域名對應的 IP，再利用 IP 去找到伺服器。\n  /blog/post1 是URL 路徑。伺服器透過這個路徑，回應特定的資源。\n  資源與其類型 剛剛說到，資源可以有不同檔案類型，如 Html文件、圖像、影片、文件等等，而這些資源瀏覽器要用相對應的方式去顯示，所以這時候伺服器必須告訴我們傳過來的資源類型(content type)，好讓瀏覽器能夠正確顯示他。這邊 Tttp 就使用了多用途網際網路郵件擴展 (Multipurpose Internet Mail Extensions，簡稱：MIME) 來指定資源類型。因此在資源回傳為 Html 文件時，伺服器回傳資源類型為 text/html，而瀏覽器就會將他視為 Html 文件並將他正確顯示。\n我們了解到 URL 與 資源之間的關係，也知道了 URL 是如何組成的，也知道當瀏覽器拿到資源後如何將資源正確的顯示，而在 URL 的組成中有提到，最開頭取得資源的方式是利用 Http 取得，實際上是如何運作及規範是什麼呢，我們得繼續去了解。\n請求 (Request) 和回應 (Response) 假設想知道時間，你去找個路人問\u0026quot;請問現在幾點\u0026quot;，你希望路人能夠回應你，首先你必須確認路人聽得懂你說話，再來他必須有手錶或任何取得時間的方法。\n我們回到 HTTP 的工作模式，HTTP 是一種請求 (Request) 和回應 (Response) 的協議，瀏覽器利用伺服器能夠理解的格式向伺服器送出一個請求，伺服器接收請求並予以回應，請求跟回應是成對的出現在一個 HTTP 工作之中的消息。而 HTTP 協定訂定了請求跟回應之間消息的內容，以便每個利用 HTTP 方式進行溝通時能夠理解並給予相對應資源。那麼我們必須得理解請求及回應各自的規範。\nHTTP 請求 分成三個部分\n 方法 每個 HTTP 請求都會有一個請求方法，該方法描述你想對請求資源做什麼，例如用 GET 方法代表想要取得該資源，以下是常見的 HTTP 方法。     方法 描述     GET 取得資源   PUT 儲存資源   DELETE 刪除資源   POST 新增資源   HEAD 取得資源 Header    在這 5 種方法中，只有 2 種是最常見的：GET 和 POST。當 Web 瀏覽器想要取得頁面、圖像、影片或文件等資源時，它會發出 GET 請求。GET 請求是最常見的請求類型。\nPOST 請求通常由網頁上的 生成 如下所示：\n\u0026lt;form action=\u0026quot;/account/create\u0026quot; method=\u0026quot;POST\u0026quot;\u0026gt; First name: \u0026lt;input id=\u0026quot;firstName\u0026quot; name=\u0026quot;firstName\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; Last name: \u0026lt;input id=\u0026quot;lastName\u0026quot; name=\u0026quot;lastName\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;submit\u0026quot;/\u0026gt; \u0026lt;form\u0026gt; 當使用者點擊 submit 按鈕時，瀏覽器會送出表單。表單告訴瀏覽器使用 POST 請求，POST 的路徑是 /account/create。瀏覽器發出的實際 HTTP 請求如下所示：\nPOST http://localhost:8080/account/create HTTP/1.1 主機：localhost:8080 firstName=Jim\u0026amp;lastName=Chien Header 在 HTTP 1.1 中，host 是必要的 HTTP Header，其他大部分是遠則要不要帶，Header 可以幫助伺服器處理請求的有用訊息，常見 Header 如下。     Header Description     Referer When the user clicks on a link, the client can send the URL of the referring page in this header.   User-Agent Information about the user agent (the software) making the request. Many applications use the information in this header, when present, to figure out what browser is making the request (IE 6 versus IE 9 versus Chrome, etc).   Accept Describes the media types (remember MIME types from Part I?) the user-agent is willing to accept.   Accept-Language Describes the languages the user-agent prefers.   Cookie Contains cookie information, which we will look at in a later article. Cookie information generally helps a server track or identify a user.   If-Modified-Since Will contain a date of when the user-agent last retrieved (and cached) the resource. The server only has to send back the entire resource if it\u0026rsquo;s been modified since that time.    URL 請求路徑  HTTP 回應 回應會有以下\n 狀態碼 (Status Code)：     範圍 分類 描述     100-199 訊息性狀態碼 接受的請求正在處理   200-299 成功狀態碼 請求正常處理完畢   300-309 重新導向 需要進行附加操作完成請求   400-499 客戶端請求錯誤 客戶端請求端請求報錯，伺服器無法處理   500-599 伺服器請求錯誤 伺服器處理請求出錯    我們可以再對每個範圍在精確的了解各個狀態碼\n   範圍 分類 描述     200 請求成功 表示伺服器成功處理請求   201 創建成功 為Http POST 請求結果，已成功在伺服器創建資源   202 接受成功 伺服器已經接收到請求，但尚未處理。通常用於有非同步處理情況，先返回202   204 沒有內容 伺服器成功處理請求，但沒有返回內容   206 部分內容成功 表示客戶端進行了範圍性的請求，且伺服器成功執行這部分的請求   301 永久性移動 請求資源的 URI 已被改變。有時候，會在回應內給予新的 URI。   302 暫時性移動 表示請求資源的 URI 臨時更改。將來可能會對 URI 進行新的更改。因此，客戶端在以後的請求中應該使用相同的 URI。   400 錯誤的請求 伺服器無法理解請求。該請求可能使用了不正確的語法。   401 未經授權 客戶端無權訪問資源，可能需要進行身份驗證。   403 禁止 服務器出於未指定的原因拒絕訪問資源。   404 沒有找到 非常常見，代表在伺服器上找不到資源。   500 內部服務器錯誤 伺服器在處理請求時遇到錯誤。通常由於 Web 應用程式錯誤而發生。   503 暫停服務 伺服器當前不會為請求提供服務。當服務器因負載過重而限制請求時，會出現此狀態代碼。     Header 有我們前面所說的資源類型(Content Type)。\n  回應內容\n  小結 至此，我稍微整理了我學習到的 HTTP 相關的規範，了解如何請求及回應，這兩個東西會成對出現，確保有來有往，請求中我們需要 URL 及 Method。回應中，我們有狀態碼，及回應內容。\n以下是這次分享的參考資料，蠻推薦看看的：\n  https://odetocode.com/Articles/741.aspx\n  https://odetocode.com/Articles/742.aspx\n  ","permalink":"https://jimchien666.github.io/blog/http1/","tags":["Http"],"title":"初次認識 Http"},{"categories":["面試"],"contents":"前幾天投了 104 履歷，非常想進這間公司做，然後在昨天時，收到 104 的一封信，是要先做一份類似小測驗，收到當下滿開心的。\n於是當天下班，我就很興奮地準備來寫這份小測驗，其中遇到一題滿有趣的，順手紀錄一下\nThere are N bulbs, numbered from 1 to N, arranged in a row. The first bulb is plugged into the power socket and each successive bulb is connected to the previous one (the second bulb to the first, the third bulb to the second, etc.). Initially, all the bulbs are turned off. At moment K (for K from 0 to N-1), we turn on the A[K]-th bulb. A bulb shines if it is on and all the previous bulbs are turned on too. Write a function solution that, given an array A of N different integers from 1 to N, returns the number of moments for which every turned on bulb shines. Examples: 1. Given A=[2, 1, 3, 5, 4], the function should return 3. - At the 0th moment only the 2nd bulb is turned on, but it does not shine because the previous one is not on. At the 1st moment two bulbs are turned on (1st and 2nd) and both of them shine. - At the 2nd moment three bulbs are turned on (1st, 2nd and 3rd) and all of them shine. At the 3rd moment four bulbs are turned on (1st, 2nd, 3rd and 5th), but the 5th bulb does not shine because the previous one is not turned on. - At the 4th moment five bulbs are turned on (1st, 2nd, 3rd, 4th and 5th) and all five of them shine. There are three moments (1st, 2nd and 4th) when every turned on bulb shines. 2. Given A=[2, 3, 4, 1, 5], the function should return 2 (at the 3rd and 4th moment every turned on bulb shines). 3. Given A=[1, 3, 4, 2, 5], the function should return 3 (at the 0th, 3rd and 4th moment every turned on bulb shines). Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; the elements of A are all distinct; each element of array A is an integer within the range [1 ..N]. 這是題目，而我的想法是，以我的了解是，開到第N次時，要亮的的條件是前面燈泡 1 到燈泡N都必須打開，所以我就每次都檢查，假設開到第三次，我就檢查前面一到三開啟哪的燈，若這中間有大於三的數字，表示說 1 ~ 3 其中一組沒亮，那整組燈就不會亮，於是我開始解題\npublic int sulation(int[] A){ int shineTimes = 0; for(int index:A){ int round = index + 1; int[] checkArray = Arrays.copyOfRange(A, 0, round); boolean isShine = true; for(int check:checkArray){ if(check\u0026gt;round){ isShine = false; } } if(isShine){ shineTimes++; } } return shineTimes; } 後來測驗完後想到的解法是，對陣列跑回圈，並記錄當下開過燈的最大值等於目前的 index 時，亮的次數就加 １\n如前三次為 [2, 1, 3] 此時最大值跟 index 相等，會亮。\n這種作法的時間服雜度為 O(N)\npublic class MySolution { public static int sulation(int[] A){ int shineTimes = 0; int currentMax = 0; for(int index=0;index\u0026lt;A.length;index++){ currentMax = Math.max(currentMax, A[index]-1); if(index==currentMax){ shineTimes++; } } return shineTimes; } public static void main(String[] args) { System.out.println(MySolution.sulation(new int[] {2, 1, 3, 5, 4})); System.out.println(MySolution.sulation(new int[] {2, 3, 4, 1, 5})); System.out.println(MySolution.sulation(new int[] {1, 3, 4, 2, 5})); } } ","permalink":"https://jimchien666.github.io/blog/interview1/","tags":["面試心得"],"title":"104 面試前測 Codility"},{"categories":["Java"],"contents":"IoC = Inversion of Control (控制反轉) 什麼是 IoC 呢？我們以印表機來舉個例子。\n假設這世界上只有Hp品牌的印表機，而學校的老師和同學們都需要一台印表機，這時我們會這麼寫\npublic interface Printer { void print(String message); } public class HpPrinter implements Printer{ @Override public void print(String message){ System.out.println(\u0026quot;HP印表機: \u0026quot; + message); } } public class Teacher { private Printer printer = new HpPrinter(); public void teach(){ printer.print(\u0026quot;I'm a teacher\u0026quot;); } } public class Student { private Printer printer = new HpPrinter(); public void learn(){ printer.print(\u0026quot;I'm a student\u0026quot;); } } 這時老師跟學生都有一台印表機，且都能將自己的身份印出\n但這時，新的印表機品牌出現了\npublic class CanonPrinter implements Printer{ @Override public void print(String message){ System.out.println(\u0026quot;Canon印表機: \u0026quot; + message); } } 這時候，如果老師跟學生都要統一換成新品牌時，我們必須改兩個地方，會造成一個困擾，假設我用 10 次，就要改 10 次，非常麻煩\n而學生跟老師只是需要一台印表機，並不在乎品牌．\n這時候呢 Spring 出現了，他幫我們保管了印表機這個 Object，而當有人需要使用印表機時，Spring 就會提供他使用\n程式就變這樣\npublic class Teacher { private Printer; public void teach(){ printer.print(\u0026quot;I'm a teacher\u0026quot;); } } public class Student { private Printer; public void learn(){ printer.print(\u0026quot;I'm a student\u0026quot;); } } 當程式啟動時，Spring 會預先存放一台印表機 Object 在Spring 容器內，而當老師或學生需要使用時，容器會提供給他們使用\n好了我們再回頭看IoC的定義\n原本印表幾的控制權教在 Teacher 和 Student 手上，而利用 Spring 後，控制權轉交到 Spring 容器手上\n由 Spring 容器去 new Object\u0008，這會帶來以下好處：\n Loose coupling 鬆耦合 Lifecycle Management 生命週期管理 More testable 方便測試  在我們了解 Spring IoC 觀念後，我們來講講如何將印表機交給 Spring 容器管理\n@Component  用法：只能加在 class 上 用途：將該 class 變成 Spring 容所管理的 object  @Component public class HpPrinter implements Printer{ @Override public void print(String message){ System.out.println(\u0026quot;HP印表機: \u0026quot; + message); } } 這時再啟動 Spring 程式時，Spring 會提供一個 Spring 容器，並把有 @Component 註解的 class new 出一個 object 並存放在容器內，而這些被 Spring 容器創建並管理的 Object，我們統稱為 Bean。\nhint. Bean 的名稱為 class name 的第一個字母轉小寫\nDI = Dependency Injection (依賴注入) 我們已經成功將 hpPrinter 成功註冊到 Spring 容器內，接下來我們要讓 Teacher 和 Student 能夠取得這台 hpPrinter\n有兩個步驟\n 將Teacher也變成Bean printer 上面加上@Autowired  @Component public class Teacher { @Autowired private Printer printer; public void teach(){ printer.print(\u0026quot;I'm a teacher\u0026quot;); } } 在 printer 上加上 @Autowired，Spring 就會將 hpPrinter 交給 teacher，這個動作稱之為 Dependency Injection(依賴注入)\n這時 teacher 就可以拿 hpPrinter 去印東西了。\n總結 IoC 與 DI 相輔相成，IoC 將 Object 存放在容器裡面，而 DI 使 Object 可以取得其他 Object 來使用\n以下為 Spring IoC 常見名詞：\n  IoC = Inversion of Control (控制反轉)\n  DI = Dependency Injection (依賴注入)\n  Bean = 存放在Spring容器裡的object\n  @Component註解 = 加在class上，將該class變成Spring容器所管理的bean\n  @Autowired註解 = 加在變數上，取得Spring容器中的Bean\n  ","permalink":"https://jimchien666.github.io/blog/post1/","tags":["Java","Spring"],"title":"Spring 中控制反轉及依賴注入"}]