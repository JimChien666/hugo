[{"categories":["面試"],"contents":"前幾天投了 104 履歷，非常想進這間公司做，然後在昨天時，收到 104 的一封信，是要先做一份類似小測驗，收到當下滿開心的。\n於是當天下班，我就很興奮地準備來寫這份小測驗，其中遇到一題滿有趣的，順手紀錄一下\nThere are N bulbs, numbered from 1 to N, arranged in a row. The first bulb is plugged into the power socket and each successive bulb is connected to the previous one (the second bulb to the first, the third bulb to the second, etc.). Initially, all the bulbs are turned off. At moment K (for K from 0 to N-1), we turn on the A[K]-th bulb. A bulb shines if it is on and all the previous bulbs are turned on too. Write a function solution that, given an array A of N different integers from 1 to N, returns the number of moments for which every turned on bulb shines. Examples: 1. Given A=[2, 1, 3, 5, 4], the function should return 3. - At the 0th moment only the 2nd bulb is turned on, but it does not shine because the previous one is not on. At the 1st moment two bulbs are turned on (1st and 2nd) and both of them shine. - At the 2nd moment three bulbs are turned on (1st, 2nd and 3rd) and all of them shine. At the 3rd moment four bulbs are turned on (1st, 2nd, 3rd and 5th), but the 5th bulb does not shine because the previous one is not turned on. - At the 4th moment five bulbs are turned on (1st, 2nd, 3rd, 4th and 5th) and all five of them shine. There are three moments (1st, 2nd and 4th) when every turned on bulb shines. 2. Given A=[2, 3, 4, 1, 5], the function should return 2 (at the 3rd and 4th moment every turned on bulb shines). 3. Given A=[1, 3, 4, 2, 5], the function should return 3 (at the 0th, 3rd and 4th moment every turned on bulb shines). Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; the elements of A are all distinct; each element of array A is an integer within the range [1 ..N]. 這是題目，而我的想法是，以我的了解是，開到第N次時，要亮的的條件是前面燈泡 1 到燈泡N都必須打開，所以我就每次都檢查，假設開到第三次，我就檢查前面一到三開啟哪的燈，若這中間有大於三的數字，表示說 1 ~ 3 其中一組沒亮，那整組燈就不會亮，於是我開始解題\npublic int sulation(int[] A){ int shineTimes = 0; for(int index:A){ int round = index + 1; int[] checkArray = Arrays.copyOfRange(A, 0, round); boolean isShine = true; for(int check:checkArray){ if(check\u0026gt;round){ isShine = false; } } if(isShine){ shineTimes++; } } return shineTimes; } 後來測驗完後想到的解法是，對陣列跑回圈，並記錄當下開過燈的最大值等於目前的 index 時，亮的次數就加 １\n如前三次為 [2, 1, 3] 此時最大值跟 index 相等，會亮。\n這種作法的時間服雜度為 O(N)\npublic class MySolution { public static int sulation(int[] A){ int shineTimes = 0; int currentMax = 0; for(int index=0;index\u0026lt;A.length;index++){ currentMax = Math.max(currentMax, A[index]-1); if(index==currentMax){ shineTimes++; } } return shineTimes; } public static void main(String[] args) { System.out.println(MySolution.sulation(new int[] {2, 1, 3, 5, 4})); System.out.println(MySolution.sulation(new int[] {2, 3, 4, 1, 5})); System.out.println(MySolution.sulation(new int[] {1, 3, 4, 2, 5})); } } ","permalink":"https://jimchien666.github.io/blog/interview1/","tags":["面試心得"],"title":"104 面試前測 Codility"},{"categories":["Java"],"contents":"IoC = Inversion of Control (控制反轉) 什麼是 IoC 呢？我們以印表機來舉個例子。\n假設這世界上只有Hp品牌的印表機，而學校的老師和同學們都需要一台印表機，這時我們會這麼寫\npublic interface Printer { void print(String message); } public class HpPrinter implements Printer{ @Override public void print(String message){ System.out.println(\u0026quot;HP印表機: \u0026quot; + message); } } public class Teacher { private Printer printer = new HpPrinter(); public void teach(){ printer.print(\u0026quot;I'm a teacher\u0026quot;); } } public class Student { private Printer printer = new HpPrinter(); public void learn(){ printer.print(\u0026quot;I'm a student\u0026quot;); } } 這時老師跟學生都有一台印表機，且都能將自己的身份印出\n但這時，新的印表機品牌出現了\npublic class CanonPrinter implements Printer{ @Override public void print(String message){ System.out.println(\u0026quot;Canon印表機: \u0026quot; + message); } } 這時候，如果老師跟學生都要統一換成新品牌時，我們必須改兩個地方，會造成一個困擾，假設我用 10 次，就要改 10 次，非常麻煩\n而學生跟老師只是需要一台印表機，並不在乎品牌．\n這時候呢 Spring 出現了，他幫我們保管了印表機這個 Object，而當有人需要使用印表機時，Spring 就會提供他使用\n程式就變這樣\npublic class Teacher { private Printer; public void teach(){ printer.print(\u0026quot;I'm a teacher\u0026quot;); } } public class Student { private Printer; public void learn(){ printer.print(\u0026quot;I'm a student\u0026quot;); } } 當程式啟動時，Spring 會預先存放一台印表機 Object 在Spring 容器內，而當老師或學生需要使用時，容器會提供給他們使用\n好了我們再回頭看IoC的定義\n原本印表幾的控制權教在 Teacher 和 Student 手上，而利用 Spring 後，控制權轉交到 Spring 容器手上\n由 Spring 容器去 new Object\u0008，這會帶來以下好處：\n Loose coupling 鬆耦合 Lifecycle Management 生命週期管理 More testable 方便測試  在我們了解 Spring IoC 觀念後，我們來講講如何將印表機交給 Spring 容器管理\n@Component  用法：只能加在 class 上 用途：將該 class 變成 Spring 容所管理的 object  @Component public class HpPrinter implements Printer{ @Override public void print(String message){ System.out.println(\u0026quot;HP印表機: \u0026quot; + message); } } 這時再啟動 Spring 程式時，Spring 會提供一個 Spring 容器，並把有 @Component 註解的 class new 出一個 object 並存放在容器內，而這些被 Spring 容器創建並管理的 Object，我們統稱為 Bean。\nhint. Bean 的名稱為 class name 的第一個字母轉小寫\nDI = Dependency Injection (依賴注入) 我們已經成功將 hpPrinter 成功註冊到 Spring 容器內，接下來我們要讓 Teacher 和 Student 能夠取得這台 hpPrinter\n有兩個步驟\n 將Teacher也變成Bean printer 上面加上@Autowired  @Component public class Teacher { @Autowired private Printer printer; public void teach(){ printer.print(\u0026quot;I'm a teacher\u0026quot;); } } 在 printer 上加上 @Autowired，Spring 就會將 hpPrinter 交給 teacher，這個動作稱之為 Dependency Injection(依賴注入)\n這時 teacher 就可以拿 hpPrinter 去印東西了。\n總結 IoC 與 DI 相輔相成，IoC 將 Object 存放在容器裡面，而 DI 使 Object 可以取得其他 Object 來使用\n以下為 Spring IoC 常見名詞：\n  IoC = Inversion of Control (控制反轉)\n  DI = Dependency Injection (依賴注入)\n  Bean = 存放在Spring容器裡的object\n  @Component註解 = 加在class上，將該class變成Spring容器所管理的bean\n  @Autowired註解 = 加在變數上，取得Spring容器中的Bean\n  ","permalink":"https://jimchien666.github.io/blog/post1/","tags":["Java","Spring"],"title":"Spring 中控制反轉及依賴注入"}]